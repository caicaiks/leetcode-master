<p align="center">
  <a href="https://mp.weixin.qq.com/s/QVF6upVMSbgvZy8lHZS3CQ"><img src="https://img.shields.io/badge/知识星球-代码随想录-blue" alt=""></a>
  <a href="https://mp.weixin.qq.com/s/b66DFkOp8OOxdZC_xLZxfw"><img src="https://img.shields.io/badge/刷题-微信群-green" alt=""></a>
  <a href="https://img-blog.csdnimg.cn/20201210231711160.png"><img src="https://img.shields.io/badge/公众号-代码随想录-brightgreen" alt=""></a>
  <a href="https://space.bilibili.com/525438321"><img src="https://img.shields.io/badge/B站-代码随想录-orange" alt=""></a>
</p>
<p align="center"><strong>欢迎大家参与本项目，贡献其他语言版本的代码，拥抱开源，让更多学习算法的小伙伴们收益！</strong></p>


> 听说这道题目把链表常见的五个操作都覆盖了？

# 707.设计链表

https://leetcode-cn.com/problems/design-linked-list/

题意：

在链表类中实现这些功能：

* get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
* addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
* addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
* addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
* deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。


![707示例](https://img-blog.csdnimg.cn/20200814200558953.png)

# 思路

如果对链表的基础知识还不太懂，可以看这篇文章：[关于链表，你该了解这些！](https://mp.weixin.qq.com/s/ntlZbEdKgnFQKZkSUAOSpQ)

如果对链表的虚拟头结点不清楚，可以看这篇文章：[链表：听说用虚拟头节点会方便很多？](https://mp.weixin.qq.com/s/slM1CH5Ew9XzK93YOQYSjA)

删除链表节点：
![链表-删除节点](https://img-blog.csdnimg.cn/20200806195114541.png)

添加链表节点：
![链表-添加节点](https://img-blog.csdnimg.cn/20200806195134331.png)

这道题目设计链表的五个接口：
* 获取链表第index个节点的数值
* 在链表的最前面插入一个节点
* 在链表的最后面插入一个节点
* 在链表第index个节点前面插入一个节点
* 删除链表的第index个节点

可以说这五个接口，已经覆盖了链表的常见操作，是练习链表操作非常好的一道题目

**链表操作的两种方式：**

1. 直接使用原来的链表来进行操作。
2. 设置一个虚拟头结点在进行操作。

下面采用的设置一个虚拟头结点（这样更方便一些，大家看代码就会感受出来）。


## 代码
```C++
class MyLinkedList {
public:
    // 定义链表节点结构体
    struct LinkedNode {
        int val;
        LinkedNode* next;
        LinkedNode(int val):val(val), next(nullptr){}
    };

    // 初始化链表
    MyLinkedList() {
        _dummyHead = new LinkedNode(0); // 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点
        _size = 0;
    }

    // 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点
    int get(int index) {
        if (index > (_size - 1) || index < 0) {
            return -1;
        }
        LinkedNode* cur = _dummyHead->next;
        while(index--){ // 如果--index 就会陷入死循环
            cur = cur->next;
        }
        return cur->val;
    }

    // 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点
    void addAtHead(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        newNode->next = _dummyHead->next;
        _dummyHead->next = newNode;
        _size++;
    }

    // 在链表最后面添加一个节点
    void addAtTail(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(cur->next != nullptr){
            cur = cur->next;
        }
        cur->next = newNode;
        _size++;
    }

    // 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。
    // 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点
    // 如果index大于链表的长度，则返回空
    void addAtIndex(int index, int val) {
        if (index > _size) {
            return;
        }
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(index--) {
            cur = cur->next;
        }
        newNode->next = cur->next;
        cur->next = newNode;
        _size++;
    }

    // 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的
    void deleteAtIndex(int index) {
        if (index >= _size || index < 0) {
            return;
        }
        LinkedNode* cur = _dummyHead;
        while(index--) {
            cur = cur ->next;
        }
        LinkedNode* tmp = cur->next;
        cur->next = cur->next->next;
        delete tmp;
        _size--;
    }

    // 打印链表
    void printLinkedList() {
        LinkedNode* cur = _dummyHead;
        while (cur->next != nullptr) {
            cout << cur->next->val << " ";
            cur = cur->next;
        }
        cout << endl;
    }
private:
    int _size;
    LinkedNode* _dummyHead;

};
```



## 其他语言版本


Java：


Python：

Go：双向链表解法

```go
type MyLinkedList struct {
    Head *Node
    Tail *Node
    Length int
}

type Node struct {
    Val int
    Prev *Node
    Next *Node
}

/** Initialize your data structure here. */
func Constructor() MyLinkedList {
    return MyLinkedList{
        Head: nil,
        Tail: nil,
        Length: 0,
    }
}


/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */
func (this *MyLinkedList) Get(index int) int {
    if !this.checkIndex(index) {
        return -1
    }
    node := this.getNode(index)
    return node.Val
}

func (this *MyLinkedList) getNode(index int) *Node {
    if !this.checkIndex(index) {
        return nil
    }
    i := 0
    node := this.Head
    for node != nil && node.Next != nil {
        if index == i {
            break
        }
        i++
        node = node.Next
    }
    return node
}

func (this *MyLinkedList) checkIndex(index int) bool {
    if index >= this.Length || index < 0 {
        return false
    }
    return true
}


/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */
func (this *MyLinkedList) AddAtHead(val int)  {
    length := this.Length
    this.Length++
    newHead := &Node{
        Val: val,
        Prev: nil,
        Next: this.Head,
    }
    if length == 0 {
        this.Head = newHead
        this.Tail = newHead
        return
    }
    
    if this.Head != nil {
        this.Head.Prev = newHead
    }
    this.Head = newHead
    
}


/** Append a node of value val to the last element of the linked list. */
func (this *MyLinkedList) AddAtTail(val int)  {
    length := this.Length
    this.Length++
    newTail := &Node{
        Val: val,
        Prev: this.Tail,
        Next: nil,
    }
    if length == 0 {
        this.Head = newTail
        this.Tail = newTail
        return
    }
    if this.Tail != nil {
        this.Tail.Next = newTail
    }

    this.Tail = newTail
    
}


/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */
func (this *MyLinkedList) AddAtIndex(index int, val int)  {
    if index <= 0 {
        this.AddAtHead(val)
        return
    }
    if index == this.Length {
        this.AddAtTail(val)
        return
    }
    indexNode := this.getNode(index)
    if indexNode == nil {
        return
    }
    newNode := &Node{
        Val: val,
        Prev: indexNode.Prev,
        Next: indexNode,
    }
    if indexNode.Prev != nil {
        indexNode.Prev.Next = newNode
    }
    indexNode.Prev = newNode
    this.Length++
}


/** Delete the index-th node in the linked list, if the index is valid. */
func (this *MyLinkedList) DeleteAtIndex(index int)  {
    indexNode := this.getNode(index)
    if indexNode == nil {
        return
    }
    this.Length--
    if this.Length == 0 {
        this.Head = nil
        this.Tail = nil
        return
    }
    if indexNode == this.Head {
        this.Head = indexNode.Next
        this.Head.Prev = nil
        return
    }
    if indexNode == this.Tail {
        this.Tail = indexNode.Prev
        this.Tail.Next = nil
        return
    }
    indexNode.Prev.Next = indexNode.Next
    indexNode.Next.Prev = indexNode.Prev
}


/**
 * Your MyLinkedList object will be instantiated and called as such:
 * obj := Constructor();
 * param_1 := obj.Get(index);
 * obj.AddAtHead(val);
 * obj.AddAtTail(val);
 * obj.AddAtIndex(index,val);
 * obj.DeleteAtIndex(index);
 */
```






-----------------------
* 作者微信：[程序员Carl](https://mp.weixin.qq.com/s/b66DFkOp8OOxdZC_xLZxfw)
* B站视频：[代码随想录](https://space.bilibili.com/525438321)
* 知识星球：[代码随想录](https://mp.weixin.qq.com/s/QVF6upVMSbgvZy8lHZS3CQ)
<div align="center"><img src=../pics/公众号.png width=450 alt=> </img></div>
